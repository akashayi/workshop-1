{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Errbot \ud83e\udd16 A Dicord chatbot that is easy to deploy and build upon! This project uses errbot and Docker to quickly launch your own chatbot in a container. The goal of this project is to make it as easy as possible to launch a minimal, working chatbot. Note: This repo is a fork of my other project errbot-launchpad - errbot-launchpad is a way more basic version of this project. This project that you are currently reading about \ud83d\udc40 is packed full of features and chatbot command that are ready to use out of the box! It is a work in progress though so beware of bugs! Looking for the bot commands documentation? Check it out here ! Quickstart \u2b50 Want to get going quick? Run the following commands to bring up a CLI to interact with errbot locally: git clone git@github.com:GrantBirki/errbot.git cd errbot make local Development Guide Check out the development guide in this repo for all the info you will need to develop, test, and build your bot! In this guide you will find details about how the bot works, and how you can create your own new chatbot commands. Just make sure to walk through the setup section before you start! Bot Invite Link \ud83d\udd17 Click here to invite errbot to your Discord server! Community Discord \ud83d\udcac If you need help with development, have a question, new feature, or just want to test out the bot, you can join the errbot community Discord Mkdocs Documentation \ud83d\udcda Docs about docs? WhOa sO mEtA Do you want to build and read the documentation locally? Perhaps you have a suggestion and want to visualize how it will look when deployed with GitHub Pages? To view and serve a local version of the Mkdocs documentation for this project, run the following command: $ mkdocs serve INFO - Building documentation... INFO - Cleaning site directory INFO - Documentation built in 0.17 seconds INFO - [12:61:00] Serving on http://127.0.0.1:8000/ What's next? Continue on to the setup section to get your environment setup and ready to build!","title":"Errbot \ud83e\udd16"},{"location":"#errbot","text":"A Dicord chatbot that is easy to deploy and build upon! This project uses errbot and Docker to quickly launch your own chatbot in a container. The goal of this project is to make it as easy as possible to launch a minimal, working chatbot. Note: This repo is a fork of my other project errbot-launchpad - errbot-launchpad is a way more basic version of this project. This project that you are currently reading about \ud83d\udc40 is packed full of features and chatbot command that are ready to use out of the box! It is a work in progress though so beware of bugs! Looking for the bot commands documentation? Check it out here !","title":"Errbot \ud83e\udd16"},{"location":"#quickstart","text":"Want to get going quick? Run the following commands to bring up a CLI to interact with errbot locally: git clone git@github.com:GrantBirki/errbot.git cd errbot make local","title":"Quickstart \u2b50"},{"location":"#development-guide","text":"Check out the development guide in this repo for all the info you will need to develop, test, and build your bot! In this guide you will find details about how the bot works, and how you can create your own new chatbot commands. Just make sure to walk through the setup section before you start!","title":"Development Guide"},{"location":"#bot-invite-link","text":"Click here to invite errbot to your Discord server!","title":"Bot Invite Link \ud83d\udd17"},{"location":"#community-discord","text":"If you need help with development, have a question, new feature, or just want to test out the bot, you can join the errbot community Discord","title":"Community Discord \ud83d\udcac"},{"location":"#mkdocs-documentation","text":"Docs about docs? WhOa sO mEtA Do you want to build and read the documentation locally? Perhaps you have a suggestion and want to visualize how it will look when deployed with GitHub Pages? To view and serve a local version of the Mkdocs documentation for this project, run the following command: $ mkdocs serve INFO - Building documentation... INFO - Cleaning site directory INFO - Documentation built in 0.17 seconds INFO - [12:61:00] Serving on http://127.0.0.1:8000/","title":"Mkdocs Documentation \ud83d\udcda"},{"location":"#whats-next","text":"Continue on to the setup section to get your environment setup and ready to build!","title":"What's next?"},{"location":"commands/","text":"Commands The following commands are all available via the chatbot: Table Key: Command : Self explanatory, the command to be executed by the chatbot Example : An example of the command and how to use it Admin Only : True/False - If the command is only available to bot admins Description : A brief description of the command Availability : Where the command is available. Possible options include: \ud83c\udf0e - Globally available everywhere the bot is present \ud83d\udd12 - Locked to certain servers / chatrooms (not publically available) \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb - Locked to the bot admins \u274c - Disabled Command Example Description Availability .help - The help command to view all available commands \ud83c\udf0e .docs - View the public documenation link for the bot \ud83c\udf0e .about - View information data about the chatbot \ud83c\udf0e .crypto .crypto btc Get the current price of a crypto currency \ud83c\udf0e .load - Get the system load \ud83c\udf0e .ping - Check if the bot is online \ud83c\udf0e .version - See what version of the bot is running \ud83c\udf0e .random fact - Get a random fun fact \ud83c\udf0e .status - View the status of the bot \ud83c\udf0e .status gc - View the garbage collection status of the bot \ud83c\udf0e .status plugins - View the status of the bot plugins \ud83c\udf0e .stats - Get the total stats for all the bot commands that have been used \ud83c\udf0e .uptime - View the bots \"uptime\" \ud83c\udf0e .insult .insult @errbot Insult a given user. Great with friends! \ud83c\udf0e .add me to league watcher .add me to league watcher <summoner_name> Add a summoner to the League watcher to \"watch\" for their games and post messages in the #league channel \ud83d\udd12 .remove me from league watcher - Remove your summoner from the League watcher \ud83d\udd12 .last match for .last match for <summoner_name> Get the last League match data for a given summoner \ud83c\udf0e .lmf .lmf <summoner_name> Get the last League match data for a given summoner (An alias for .last match for ) \ud83c\udf0e .league disable - Disable the League watcher \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb .league enable - Enable the League watcher \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb .league streak - View your current league win/loss streak \ud83d\udd12 .add to league watcher .add to league watcher --summoner birki --discord birki#0001 --guild 12345 Admin command to add a summoner + Discord handle combo to a given guild for the League watcher \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb .remove from league watcher .remove from league watcher --discord <discord_guild_id> --summoner <summoner_name> Admin command to remove a summoner in a specific discord guild from the league watcher \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb .view my league watcher data .view my league watcher data View your league watcher data \ud83d\udd12 .loud .loud rickroll.mp3 Play a very loud sound from the sounds folder on the bot \ud83d\udd12 .loud list - List all the mp3 sound files which can be used by the .loud command \ud83c\udf0e .loud random - Play a random sound from the sounds folder on the bot \ud83c\udf0e .play .play <youtube_url> Play a song, or sound from YouTube - Optionally use --queue <number> to select the queue position to play the song \ud83d\udd12 .play help - View a detailed and pretty help command for .play \ud83d\udd12 .play queue - See what is in the .play queue \ud83d\udd12 .play stats - See the all time stats for the .play command in your server \ud83d\udd12 .skip - Skip the current song playing / at the top of the queue \ud83d\udd12 .stop - Stop the current song and nuke the whole .play queue \ud83d\udd12 .rem .rem <key> is <value> Have the bot remember something - Inspired by hubot under the MIT license \ud83c\udf0e .forget .forget <key> Make the bot forget something that is being remembered \ud83c\udf0e .remember .rememeber <key> is <value> The \"longform\" version of the .rem command \ud83c\udf0e .tts .tts hello world! I will be read over text to speech Read a text message over text to speech in a voice channel (that you are connected to) \ud83d\udd12 .echo .echo hello A simple command to echo back a message (Like the Linux \"echo\" binary) \ud83c\udf0e .history - View the past few commands (history) that have been used by the bot \ud83c\udf0e .log tail - Tail / View the bots latest log messages that have been written \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb .users - See a total count of all the users that 'could' interact with the bot in all servers \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb .servers - See a list of all active servers the bot is in \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb .ban .ban user#1234 Ban a user from interacting with the bot \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb .banned users - View all the users that have been banned \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb .unban .unban user#1234 Remove a ban for a given user \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb .ban .ban server 1234567890 Ban an entire server from interacting with the bot \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb .banned servers - View all the servers that have been banned \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb .unban server .unban server 1234567890 Remove a ban for a given server \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb .render test - Render a sample message with errbot to see how the chat service handles it \ud83c\udf0e .whoami - Return a block of data about who the bot thinks you are \ud83c\udf0e .wallstreetbets - View the top trending stonks from /r/wallstreetbets \ud83c\udf0e .sparkle .sparkle @username for being awesome Sparkle a user to show your appreciation! (optionally provide a reason for the sparkling) - Inspired by pwn \ud83c\udf0e .show sparkles .show sparkes - .show sparkles for @username View the sparkles (and their reasons) for yourself or another user - Inspired by pwn \ud83c\udf0e .down .down twitter Get a DownDetector graph and the status for a given service \ud83c\udf0e .eft help - Help message for all .eft commands \ud83c\udf0e .eft .eft clock Get an Escape from Tarkov item and its value \ud83c\udf0e .eft ammo .eft ammo 7.62x39mm Get information about an ammo type \ud83c\udf0e .eft ammo help - Get information about the ammo types that can be used with the .eft ammo command \ud83c\udf0e .eft status .eft status - .eft status --messages Get the current status of the Escape from Tarkov servers \ud83c\udf0e .eft map .eft map shoreline Get an image of a map for a given Tarkov location \ud83c\udf0e .eft map help - Get information about the maps that can be used with the .eft map command \ud83c\udf0e .eft time - Get the current time in Tarkov \ud83c\udf0e .eft track .eft track --item <item> --threshold <threshold> --channel <channel> Track an item for price changes in Escape from Tarkov - Note: Make sure to wrap --item \"search with spaces\" in quotes if it contains spaces \ud83c\udf0e .eft untrack .eft untrack <item> Stop tracking a tracked item for price changes in Escape from Tarkov \ud83c\udf0e .eft track help - Get the detailed help command for the Escape from Tarkov item tracker \ud83c\udf0e Note: . is the bot prefix to invoke the bot in production and ! is often used for development","title":"Commands"},{"location":"commands/#commands","text":"The following commands are all available via the chatbot: Table Key: Command : Self explanatory, the command to be executed by the chatbot Example : An example of the command and how to use it Admin Only : True/False - If the command is only available to bot admins Description : A brief description of the command Availability : Where the command is available. Possible options include: \ud83c\udf0e - Globally available everywhere the bot is present \ud83d\udd12 - Locked to certain servers / chatrooms (not publically available) \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb - Locked to the bot admins \u274c - Disabled Command Example Description Availability .help - The help command to view all available commands \ud83c\udf0e .docs - View the public documenation link for the bot \ud83c\udf0e .about - View information data about the chatbot \ud83c\udf0e .crypto .crypto btc Get the current price of a crypto currency \ud83c\udf0e .load - Get the system load \ud83c\udf0e .ping - Check if the bot is online \ud83c\udf0e .version - See what version of the bot is running \ud83c\udf0e .random fact - Get a random fun fact \ud83c\udf0e .status - View the status of the bot \ud83c\udf0e .status gc - View the garbage collection status of the bot \ud83c\udf0e .status plugins - View the status of the bot plugins \ud83c\udf0e .stats - Get the total stats for all the bot commands that have been used \ud83c\udf0e .uptime - View the bots \"uptime\" \ud83c\udf0e .insult .insult @errbot Insult a given user. Great with friends! \ud83c\udf0e .add me to league watcher .add me to league watcher <summoner_name> Add a summoner to the League watcher to \"watch\" for their games and post messages in the #league channel \ud83d\udd12 .remove me from league watcher - Remove your summoner from the League watcher \ud83d\udd12 .last match for .last match for <summoner_name> Get the last League match data for a given summoner \ud83c\udf0e .lmf .lmf <summoner_name> Get the last League match data for a given summoner (An alias for .last match for ) \ud83c\udf0e .league disable - Disable the League watcher \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb .league enable - Enable the League watcher \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb .league streak - View your current league win/loss streak \ud83d\udd12 .add to league watcher .add to league watcher --summoner birki --discord birki#0001 --guild 12345 Admin command to add a summoner + Discord handle combo to a given guild for the League watcher \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb .remove from league watcher .remove from league watcher --discord <discord_guild_id> --summoner <summoner_name> Admin command to remove a summoner in a specific discord guild from the league watcher \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb .view my league watcher data .view my league watcher data View your league watcher data \ud83d\udd12 .loud .loud rickroll.mp3 Play a very loud sound from the sounds folder on the bot \ud83d\udd12 .loud list - List all the mp3 sound files which can be used by the .loud command \ud83c\udf0e .loud random - Play a random sound from the sounds folder on the bot \ud83c\udf0e .play .play <youtube_url> Play a song, or sound from YouTube - Optionally use --queue <number> to select the queue position to play the song \ud83d\udd12 .play help - View a detailed and pretty help command for .play \ud83d\udd12 .play queue - See what is in the .play queue \ud83d\udd12 .play stats - See the all time stats for the .play command in your server \ud83d\udd12 .skip - Skip the current song playing / at the top of the queue \ud83d\udd12 .stop - Stop the current song and nuke the whole .play queue \ud83d\udd12 .rem .rem <key> is <value> Have the bot remember something - Inspired by hubot under the MIT license \ud83c\udf0e .forget .forget <key> Make the bot forget something that is being remembered \ud83c\udf0e .remember .rememeber <key> is <value> The \"longform\" version of the .rem command \ud83c\udf0e .tts .tts hello world! I will be read over text to speech Read a text message over text to speech in a voice channel (that you are connected to) \ud83d\udd12 .echo .echo hello A simple command to echo back a message (Like the Linux \"echo\" binary) \ud83c\udf0e .history - View the past few commands (history) that have been used by the bot \ud83c\udf0e .log tail - Tail / View the bots latest log messages that have been written \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb .users - See a total count of all the users that 'could' interact with the bot in all servers \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb .servers - See a list of all active servers the bot is in \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb .ban .ban user#1234 Ban a user from interacting with the bot \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb .banned users - View all the users that have been banned \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb .unban .unban user#1234 Remove a ban for a given user \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb .ban .ban server 1234567890 Ban an entire server from interacting with the bot \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb .banned servers - View all the servers that have been banned \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb .unban server .unban server 1234567890 Remove a ban for a given server \ud83d\udd12\ud83d\udc68\u200d\ud83d\udcbb .render test - Render a sample message with errbot to see how the chat service handles it \ud83c\udf0e .whoami - Return a block of data about who the bot thinks you are \ud83c\udf0e .wallstreetbets - View the top trending stonks from /r/wallstreetbets \ud83c\udf0e .sparkle .sparkle @username for being awesome Sparkle a user to show your appreciation! (optionally provide a reason for the sparkling) - Inspired by pwn \ud83c\udf0e .show sparkles .show sparkes - .show sparkles for @username View the sparkles (and their reasons) for yourself or another user - Inspired by pwn \ud83c\udf0e .down .down twitter Get a DownDetector graph and the status for a given service \ud83c\udf0e .eft help - Help message for all .eft commands \ud83c\udf0e .eft .eft clock Get an Escape from Tarkov item and its value \ud83c\udf0e .eft ammo .eft ammo 7.62x39mm Get information about an ammo type \ud83c\udf0e .eft ammo help - Get information about the ammo types that can be used with the .eft ammo command \ud83c\udf0e .eft status .eft status - .eft status --messages Get the current status of the Escape from Tarkov servers \ud83c\udf0e .eft map .eft map shoreline Get an image of a map for a given Tarkov location \ud83c\udf0e .eft map help - Get information about the maps that can be used with the .eft map command \ud83c\udf0e .eft time - Get the current time in Tarkov \ud83c\udf0e .eft track .eft track --item <item> --threshold <threshold> --channel <channel> Track an item for price changes in Escape from Tarkov - Note: Make sure to wrap --item \"search with spaces\" in quotes if it contains spaces \ud83c\udf0e .eft untrack .eft untrack <item> Stop tracking a tracked item for price changes in Escape from Tarkov \ud83c\udf0e .eft track help - Get the detailed help command for the Escape from Tarkov item tracker \ud83c\udf0e Note: . is the bot prefix to invoke the bot in production and ! is often used for development","title":"Commands"},{"location":"configuration/","text":"Configuration This section will walk you through configuring your bot to make it uniquely yours! The mighty .env files All configuration to the bot is done through environment variables. This is done to make local dev easily mirror production and be configured in the same way. There are two kinds of variables: Sensitive environment variables Everything else These variables are split out into their own respective .env files config.env - Environment variables related to the overall configuration of the bot. This file can and should be committed creds.env - Sensitive environement variables containing secrets, API keys, tokens, etc. This file should absolutely not be committed ever config.env This file has a lot of comments describing each option so I won't go into too many details here. In this file you can make general configuration changes to the bot to alter how it behaves. Below are a few examples: BOT_PREFIX='!' - This allows you to change the character that you invoke your bot with. For example, you could have it be . instead of a ! (I like the . ) -> .uptime BOT_HOME_CHANNEL - The \"home channel\" of the bot. Can be useful to have this set if you have a cron that posts messages at a certain time to a certain channel, like weather updates BOT_ADMINS - Set the \"admin\" users of the bot. Can be used in combination with the @botcmd(admin_only=True) decorator to prevent non-admins from using a certain command creds.env \u26a0\ufe0f Once again do not ever commit this file to your version control system! This file contains secrets and credentials that your bot needs to run. The only credential that is needed to run the bot is the CHAT_SERVICE_TOKEN which is what you use to connect to your desired chat service (Discord, Slack, etc). All the rest are optional! Examples below: Required: CHAT_SERVICE_TOKEN='<token>' - The token to connect your bot to its chat service Optional Examples: AWS_ACCESS_KEY_ID='<token>' & AWS_SECRET_ACCESS_KEY='<token>' - AWS tokens if you are using DynamoDB for state persistence RIOT_TOKEN - An API token from RIOT to enable the League of Legends gameplay watcher plugin SPOTIFY_CLIENT_ID='<token>' & SPOTIFY_CLIENT_SECRET='<token>' - Spotify tokens to enable extra Spotify lookups on songs played with the .play command SENTRY='https://<id>@<id>.ingest.sentry.io/<id>' - Sentry.io url endpoint for sending exception events for your bot (I love this personally) Check out the creds.env.example file to see more examples of this file's contents A note on optional credentials as seen above: A few of the tokens listed above are optional and enable extra features to the bot when provided as environment variables. You can see more information on these in the configuration table below. Configuration Table Now that you have a general understanding about how environment variables are used to configure the bot, let's look at a table of the configuration options that are available: config.env : ENV VAR Value Required / Optional Description BOT_NAME Any alpha-numeric character Required A unique identifier that will be used in the logs for identifying your bot. This value should be unique if you have multiple bots running in the same environment BACKEND Discord / Slack / etc Required Set the desired chat backend for the bot BOT_PREFIX Any alpha-numeric character Required Set the character prefix used to invoke the bot ( . is suggested) BOT_HOME_CHANNEL Any string related to a text channel name Optional Set a home channel for the bot as a default. Example, posting messages to a channel on a schedule like weather updates IMAGE_TAG String Optional An image tag / version number to use to identify the version of the bot that is running BOT_ADMINS String (ex: Username#0001 ) Optional The username in the chat-service provided format. Examples: Username#0001 for Discord and @user.name for Slack BOT_EXTRA_BACKEND_DIR /app/backend/err-backend-discord Depends This variable is optional if you are not using a backend that requires it. If you are using a backend like Discord, then this is required BOT_STATUS_MESSAGE String Optional Certain chat services like Discord allow you to have a status message next to your bot's name. This variable allows you to provide that DISABLE_LEAGUE_CRON True Optional A variable used to disable or enable the \"cron\" like functionality for the .league plugin which posts match results at a set interval (like a cron job) DOCS_URL String Optional A link that will be provided to users when the .docs command is invoked LOCALSTACK http://localstack:4566 Required (locally) If you are using LocalStack (you are by default) then this variable provides the URL to the localstack endpoint when testing locally with docker-compose SENTRY_DISABLED True Optional An optional variable that can be provided to manually disable the Sentry.io extension creds.env : ENV VAR Value Required / Optional Description CHAT_SERVICE_TOKEN String Required The token used to authenticate to your desired chat service AWS_ACCESS_KEY_ID String Optional If you are using AWS DynamoDB for persistence, then you can provide this for authentication AWS_SECRET_ACCESS_KEY String Optional If you are using AWS DynamoDB for persistence, then you can provide this for authentication RIOT_TOKEN String Optional Add your RIOT API token to enable the .league chat commands and features SPOTIFY_CLIENT_ID String Optional Add your Spotify API credentials to enable Spotify song detail lookups and URLs for the .play command SPOTIFY_CLIENT_SECRET String Optional Add your Spotify API credentials to enable Spotify song detail lookups and URLs for the .play command SENTRY Sentry DSN in the following format: https://<id>@<id>.ingest.sentry.io/<id> Optional Add your Sentry.io DSN in the URL format to enable logging exceptions to Sentry.io Table Key Details: ENV VAR - The variable name to be provided Value - An example of the value(s) that can be provided Required / Optional - Whether or not the variable is required or optional Description - A description of what the variable is used for What About Production? Related to this section is the deployment page How do we get these environment variables into our container when deploying to production you ask? Well that really depends on how you are deploying your container to production. I will provide a few options below to give you some ideas: For config.env : Apply your environment variables in your container definintion if you are using Kubernetes Bake your environment variables into your container when building the image (meh) Load the config.env file into the container or mount a volume with this file that the container has access to. Then read the file and populate the environment variables Store the variables in a remote config store and read them from there For creds.env : Use k8s secrets for when deploying to Kubernetes -> terraform/k8s/modules/containers/errbot/secret.yaml Use Hashicorp Vault to inject secrets from creds.env Use an external service like AWS Secrets Manager and read from there What's next? Continue on to the development section to learn more about how to build your bot, add new commands, and more!","title":"Configuration"},{"location":"configuration/#configuration","text":"This section will walk you through configuring your bot to make it uniquely yours!","title":"Configuration"},{"location":"configuration/#the-mighty-env-files","text":"All configuration to the bot is done through environment variables. This is done to make local dev easily mirror production and be configured in the same way. There are two kinds of variables: Sensitive environment variables Everything else These variables are split out into their own respective .env files config.env - Environment variables related to the overall configuration of the bot. This file can and should be committed creds.env - Sensitive environement variables containing secrets, API keys, tokens, etc. This file should absolutely not be committed ever","title":"The mighty .env files"},{"location":"configuration/#configenv","text":"This file has a lot of comments describing each option so I won't go into too many details here. In this file you can make general configuration changes to the bot to alter how it behaves. Below are a few examples: BOT_PREFIX='!' - This allows you to change the character that you invoke your bot with. For example, you could have it be . instead of a ! (I like the . ) -> .uptime BOT_HOME_CHANNEL - The \"home channel\" of the bot. Can be useful to have this set if you have a cron that posts messages at a certain time to a certain channel, like weather updates BOT_ADMINS - Set the \"admin\" users of the bot. Can be used in combination with the @botcmd(admin_only=True) decorator to prevent non-admins from using a certain command","title":"config.env"},{"location":"configuration/#credsenv","text":"\u26a0\ufe0f Once again do not ever commit this file to your version control system! This file contains secrets and credentials that your bot needs to run. The only credential that is needed to run the bot is the CHAT_SERVICE_TOKEN which is what you use to connect to your desired chat service (Discord, Slack, etc). All the rest are optional! Examples below: Required: CHAT_SERVICE_TOKEN='<token>' - The token to connect your bot to its chat service Optional Examples: AWS_ACCESS_KEY_ID='<token>' & AWS_SECRET_ACCESS_KEY='<token>' - AWS tokens if you are using DynamoDB for state persistence RIOT_TOKEN - An API token from RIOT to enable the League of Legends gameplay watcher plugin SPOTIFY_CLIENT_ID='<token>' & SPOTIFY_CLIENT_SECRET='<token>' - Spotify tokens to enable extra Spotify lookups on songs played with the .play command SENTRY='https://<id>@<id>.ingest.sentry.io/<id>' - Sentry.io url endpoint for sending exception events for your bot (I love this personally) Check out the creds.env.example file to see more examples of this file's contents A note on optional credentials as seen above: A few of the tokens listed above are optional and enable extra features to the bot when provided as environment variables. You can see more information on these in the configuration table below.","title":"creds.env"},{"location":"configuration/#configuration-table","text":"Now that you have a general understanding about how environment variables are used to configure the bot, let's look at a table of the configuration options that are available: config.env : ENV VAR Value Required / Optional Description BOT_NAME Any alpha-numeric character Required A unique identifier that will be used in the logs for identifying your bot. This value should be unique if you have multiple bots running in the same environment BACKEND Discord / Slack / etc Required Set the desired chat backend for the bot BOT_PREFIX Any alpha-numeric character Required Set the character prefix used to invoke the bot ( . is suggested) BOT_HOME_CHANNEL Any string related to a text channel name Optional Set a home channel for the bot as a default. Example, posting messages to a channel on a schedule like weather updates IMAGE_TAG String Optional An image tag / version number to use to identify the version of the bot that is running BOT_ADMINS String (ex: Username#0001 ) Optional The username in the chat-service provided format. Examples: Username#0001 for Discord and @user.name for Slack BOT_EXTRA_BACKEND_DIR /app/backend/err-backend-discord Depends This variable is optional if you are not using a backend that requires it. If you are using a backend like Discord, then this is required BOT_STATUS_MESSAGE String Optional Certain chat services like Discord allow you to have a status message next to your bot's name. This variable allows you to provide that DISABLE_LEAGUE_CRON True Optional A variable used to disable or enable the \"cron\" like functionality for the .league plugin which posts match results at a set interval (like a cron job) DOCS_URL String Optional A link that will be provided to users when the .docs command is invoked LOCALSTACK http://localstack:4566 Required (locally) If you are using LocalStack (you are by default) then this variable provides the URL to the localstack endpoint when testing locally with docker-compose SENTRY_DISABLED True Optional An optional variable that can be provided to manually disable the Sentry.io extension creds.env : ENV VAR Value Required / Optional Description CHAT_SERVICE_TOKEN String Required The token used to authenticate to your desired chat service AWS_ACCESS_KEY_ID String Optional If you are using AWS DynamoDB for persistence, then you can provide this for authentication AWS_SECRET_ACCESS_KEY String Optional If you are using AWS DynamoDB for persistence, then you can provide this for authentication RIOT_TOKEN String Optional Add your RIOT API token to enable the .league chat commands and features SPOTIFY_CLIENT_ID String Optional Add your Spotify API credentials to enable Spotify song detail lookups and URLs for the .play command SPOTIFY_CLIENT_SECRET String Optional Add your Spotify API credentials to enable Spotify song detail lookups and URLs for the .play command SENTRY Sentry DSN in the following format: https://<id>@<id>.ingest.sentry.io/<id> Optional Add your Sentry.io DSN in the URL format to enable logging exceptions to Sentry.io Table Key Details: ENV VAR - The variable name to be provided Value - An example of the value(s) that can be provided Required / Optional - Whether or not the variable is required or optional Description - A description of what the variable is used for","title":"Configuration Table"},{"location":"configuration/#what-about-production","text":"Related to this section is the deployment page How do we get these environment variables into our container when deploying to production you ask? Well that really depends on how you are deploying your container to production. I will provide a few options below to give you some ideas: For config.env : Apply your environment variables in your container definintion if you are using Kubernetes Bake your environment variables into your container when building the image (meh) Load the config.env file into the container or mount a volume with this file that the container has access to. Then read the file and populate the environment variables Store the variables in a remote config store and read them from there For creds.env : Use k8s secrets for when deploying to Kubernetes -> terraform/k8s/modules/containers/errbot/secret.yaml Use Hashicorp Vault to inject secrets from creds.env Use an external service like AWS Secrets Manager and read from there","title":"What About Production?"},{"location":"configuration/#whats-next","text":"Continue on to the development section to learn more about how to build your bot, add new commands, and more!","title":"What's next?"},{"location":"deployment/","text":"Deployment Note: This section is mostly for my own docs for this repo and its contributors. You can use it as a guide for your own fork of this project Deploying your changes to the prod instance of errbot is really easy. We will use the .cat meow example from the development section All you need to do is the following: Create a new branch cat-meow-feature Commit your changes to the cat-meow-feature branch Push your changes Open up github.com/GrantBirki/errbot/pulls and create a new pull request Wait for CI to finish and for all checks to pass View your Terraform output and ensure it looks like it is doing what you want it to (ie: not destroying resources) Request review on your pull request and obtain an approval (@grantbirki or any other member) Merge your pull request and your change will be automatically deployed! \ud83d\ude80\u2728 Run .cat meow in Discord to see your command in action \ud83d\udc08 Tagging a Release \ud83c\udff7 Once you have deployed your changes via a merge, it is recommended to create a new release via a Git tag This can be easily accomplished by using the following helper script: script/release This will create a tag with the following format ( vX.X.X ) and push it to the remote repo If you changes are minor and do not require a release, you may skip this step Create release tags from the main branch Deploying from Scratch to Azure with GitHub Actions This sections is mostly my own notes and for those who are deploying this project with GitHub Actions to Azure AKS If there are currently no resources deployed for this project you will need to follow the steps below to \"deploy from scratch\": Run the make build command from the root of this repo Once the local deploy is complete, login to your Azure account and go to the errbot ACR registry that was created Copy the ACR username and password and add it to GitHub Actions secrets Copy your ~/.kube/config file and add it to GitHub Actions secrets You may now deploy the pipeline through GitHub Actions What's next? Continue on to the observability section to learn more about how to observe and monitor your bot's performance \ud83d\udd2d","title":"Deployment"},{"location":"deployment/#deployment","text":"Note: This section is mostly for my own docs for this repo and its contributors. You can use it as a guide for your own fork of this project Deploying your changes to the prod instance of errbot is really easy. We will use the .cat meow example from the development section All you need to do is the following: Create a new branch cat-meow-feature Commit your changes to the cat-meow-feature branch Push your changes Open up github.com/GrantBirki/errbot/pulls and create a new pull request Wait for CI to finish and for all checks to pass View your Terraform output and ensure it looks like it is doing what you want it to (ie: not destroying resources) Request review on your pull request and obtain an approval (@grantbirki or any other member) Merge your pull request and your change will be automatically deployed! \ud83d\ude80\u2728 Run .cat meow in Discord to see your command in action \ud83d\udc08","title":"Deployment"},{"location":"deployment/#tagging-a-release","text":"Once you have deployed your changes via a merge, it is recommended to create a new release via a Git tag This can be easily accomplished by using the following helper script: script/release This will create a tag with the following format ( vX.X.X ) and push it to the remote repo If you changes are minor and do not require a release, you may skip this step Create release tags from the main branch","title":"Tagging a Release \ud83c\udff7"},{"location":"deployment/#deploying-from-scratch-to-azure-with-github-actions","text":"This sections is mostly my own notes and for those who are deploying this project with GitHub Actions to Azure AKS If there are currently no resources deployed for this project you will need to follow the steps below to \"deploy from scratch\": Run the make build command from the root of this repo Once the local deploy is complete, login to your Azure account and go to the errbot ACR registry that was created Copy the ACR username and password and add it to GitHub Actions secrets Copy your ~/.kube/config file and add it to GitHub Actions secrets You may now deploy the pipeline through GitHub Actions","title":"Deploying from Scratch to Azure with GitHub Actions"},{"location":"deployment/#whats-next","text":"Continue on to the observability section to learn more about how to observe and monitor your bot's performance \ud83d\udd2d","title":"What's next?"},{"location":"development/","text":"Development Looking to add a feature, enchance an existing one, or contribute to this bot? You have come to the right place! The first step to contributing to this bot is getting your environment setup. This is covered on the main document under the setup section so make sure you have the prerequisites section checked off before continuing. Understanding the Bot Let's understand all the parts of the this repo so we are familiar before we begin About the Infrastructure Here is a high level overview of this project and the software/infrastruce that run this bot: Core: This project uses errbot which is a Python based chatop/chatbot framework errbot and all of its components are built using Docker to create a deployable image We use Terraform and GitHub actions to deploy the Docker image (from our CI/CD pipeline) to Azure AKS (Kubernetes) The Docker image runs in a container in Azure AKS and connects to Discord The bot then listens for commands and responds to them For any commands that require some form of \"state\" we use AWS DynamoDB to store information since containers are ephemeral by design - We use LocalStack to mock AWS when developing locally \ud83d\ude09 We store any configuration as environment variables and secrets as k8s secrets which get injected into the container on boot Project Folder/File Information What is in each folder? .github/ - Mainly GitHub workflows for actions script/ - Maintenance and automation scripts for working with this project script/k8s/ - Kubernetes deployment scripts for local development script/localstack/ - Files and Dockerfiles related to building the localstack container for development template/ - Template / boilerplate code for new chatops commands terraform/ - Terraform code for deploying errbot resources terraform/aws - AWS related resources terraform/k8s-cluster - The core components of the errbot k8s cluster terraform/k8s - The k8s resources, services, manifests, secrets, etc to get deployed on the k8s-cluster src/ - All the files, data, and configuration for errbot and its related services src/errbot/backend/ - Folder containing extra backend modules (Discord) src/errbot/ - Folder containing all the extra / custom plugins for our chatop commands src/errbot/lib/ - Folder containing shared libraries for plugins What are these files? .gitignore - Used for ignoring files from Git config.env - Used for adding non-sensitive environment variables to your local instance of errbot creds.env - Used for adding sensitive environment variables to your local instance of errbot docker-compose.yml - Used for starting errbot locally with Docker-Compose Makefile - Used to easily invoke scripts in this repo *.md - Documentation! Okay, now let's get started! Running the Bot Locally \ud83e\udd16 This should look familiar from the setup section Let's create a local instance of Errbot : $ make local [#] Starting local bot test environment [#] Killing old docker processes docker-compose rm -fs Stopping chatbot ... done Going to remove chatbot Removing chatbot ... done [#] Building docker containers docker-compose build Building chatbot [+] Building 1.3s (22/22) FINISHED [#] TEST Container is now running! [#] Interact with me over the CLI prompt below [@local_admin \u27a1 @errbot] >>> You can now interact with Errbot from the command line! Type a command like .help to get an output of all the commands that are available So what exactly does make local do? docker-compose rm -fs Removes and destroys any errbot_chatbot Docker containers (if running) docker-compose build Rebuilds the errbot_chatbot Docker container and bakes in any new changes you have made. The Docker build packages up components from the src/errbot directory Runs docker run -it --rm --env-file config.env --env-file creds.env -e LOCAL_TESTING=True errbot_chatbot:latest - Let's break this one down.. This starts the errbot_chatbot:latest container in interactive mode ( -it ) Removes the container once you exit the CLI ( --rm ) Uses the config.env file to load non-sensitive environment variables ( --env-file config.env ) Uses the creds.env file to load sensitive environment variables ( --env-file creds.env ) Specifies the LOCAL_TESTING=True environment variable ( -e LOCAL_TESTING=True ) - Used in app/config.py Pops open a CLI prompt when complete for you to interact and issues commands to test and develop errbot Okay, so we started up the bot, hooray! Now lets go over how to create a chatop command Creating a new ChatOp Command \ud83d\udee0\ufe0f Before we create a new chatop command, let's go over it a bit. About ChatOp Commands Click to expand each section and learn more about chatops What is a chatop command? .help , .uptime , .whoami , .example are all examples of chatop commands The first three commands listed above ( .help , .uptime , .whoami ) are builtin commands. This means that they come with the errbot framework . The last command listed above ( .example ) is a plugin command. This means that it is a chatop command which we created for our own use! This guide will focus on plugins which are chatops commands that we write and bake into our chatbot. Where are chatop commands stored? They are stored in the src/errbot/plugins folder. Each chatop command is then stored in its own subfolder: src/errbot/example What is the src/errbot/lib folder? Good thing you asked! This is a special folder for storing shared/common libraries between chatop commands. For example, let's say you had two chatop functions .send cat meme and .send dog meme . People were spamming memes too fast so you needed to rate limit both commands. You could add a shared rate_limit_memes() function in src/errbot/lib/common and then import that function into both your cat and dog chatops. Check out the src/errbot/lib folder to see examples in action Okay cool beans, now that we know a bit more about chatops commands, let's create a brand new one Creating a command At the root of this repo you will notice a template folder. This folder contains the bare minimum code to create a brand new chatop command. Since copying this file from the template folder to the src/errbot/template folder takes about 1 brain cell too many, there is a script to do it for you. Run the following command to copy the template folder into the plugin directory: make command Follow the prompts from this script and create a new command (maybe something like .cat meow ) Making a new command by hand (eww) Enter the `src/errbot/template` folder and poke around the two files you see in there for a bit. In order to make a new chatop command you just need to change a few lines to the new name of you function / functions. Let's say we want to make a new chatop command that responds with some simple text like \"meow\" and it is invoked by typing `.cat meow`. To do so, make the following changes: 1. Change the name of the `src/errbot/template` folder: `src/errbot/template` -> `src/errbot/catmeow` 2. Change the name of the `src/errbot/template/template.plug` file: `src/errbot/template/template.plug` -> `src/errbot/template/catmeow.plug` 3. Change the name of the `src/errbot/template/template.py` file: `src/errbot/template/template.py` -> `src/errbot/template/catmeow.py` 4. Inside of the `src/errbot/template/template.plug` file change all occurrences of `Template` or `template` to `Catmeow` or `catmeow`: Example: `Name = Template # Change me!` -> `Name = Catmeow` Example: `Module = template # Change me!` -> `Module = catmeow` > Note the cases of T/t and C/c above 5. Inside of the `src/errbot/template/template.py` file change the class name: `class Template(BotPlugin): # Change me!` -> `class Catmeow(BotPlugin):` 6. Inside of the `src/errbot/template/template.py` file change the function name: `def template(self, msg, args): # Change me! (function name)` -> `def cat_meow(self, msg, args):` > Note: We use `_` (underscores) in function names to represent spaces in our command. `def cat_meow(...)` becomes `.cat meow` via the chatop 7. To make the `.cat meow` command return something, edit the return message: `return 'Hello world, I am a template!'` -> `return 'meow!'` Once you follow through all the prompts from the script, you should have a new folder in src/errbot/plugins/<new-command-name> Open up the Python file in that directory to add some code. It will be a template for you to edit and bring your .cat meow command to life. I will include a snippet below of what it could look like: from errbot import BotPlugin, botcmd class CatMeow(BotPlugin): \"\"\"A chat command that sends cat noises\"\"\" @botcmd def cat_meow(self, msg, args): \"\"\"Makes a cat noise\"\"\" return \"meeeeoowww\" Let's break down what each line of the snippet above does: from errbot import BotPlugin, botcmd # Imports the errbot plugins and decorators to make a function into a bot command class CatMeow(BotPlugin): # Creates a new class for all our Cat related bot commands. # A class can contain many or just a single bot command @botcmd # The mighty bot decorator that turns the function into a bot command! def cat_meow(self, msg, args): # The bot command (more info below this code snippet) \"\"\"Makes a cat noise\"\"\" # A docstring that can be viewed via the bot's 'help' command return \"meeeeoowww\" # The String which the bot returns when invoked for this bot command The Bot Command : In the snippet above, the line def cat_meow(self, msg, args) has a lot to unpack. This function has a decorator applied to it that turns it into a bot command. During run time, the BOT_PREFIX from the config.env file (in the root of this repo) get applied to the front of the function name and all _ (underscores) become spaces. So cat_meow ultimately becomes !cat meow as a bot command for example. self , msg , and args are all required errbot params for this function to work. To see what attributes these objects contain I would suggest looking at src/errbot/plugins/example/example.py or taking a deeper looking into the official errbot documentation . Okay, that's enough of that.. let's start the bot and test out our new .cat meow command! To test, cd to the root of this repo and run make local . Your new plugin should be loaded and you can interact with it via the CLI: Note: I use . to invoke my bot but that is ultimately determined on what you have you BOT_PREFIX set to in the config.env file. [@local_admin \u27a1 @errbot] >>> .cat meow meeeeoowww Linting your code This section is specific to the GrantBirki/errbot repo for the CI/CD pipeline and to adhear to code linting standards in this repo In order for CI to pass, you must have properly linted code. Luckily, this is extremely easy to do and can be performed in a single command: $ script/lint All done! \u2728 \ud83c\udf70 \u2728 1 file reformatted, 14 files left unchanged. That's it! This will lint all *.py files in the repo to ensure they conform to the Black linting guidelines Linting is just the formatting of your code to a certain standard (ie: no trailing whitespaces, \"\" quotes instead of '', etc) Kubernetes So far, in these docs we have been using docker-compose to run the bot. This is great for testing and development but it is not ideal for production or testing changes right before deploying to production. Like most containerized applications, Kubernetes is a great option. Kubernetes is what I use personally to deploy this bot. In order to closely mimic the docker-compose setup and the production Kubernetes setup we can use minikube to bridge the two together. Note: docker-compose is still the suggested method for developing locally because it is easier and quicker to test changes. Kubernetes is best suited for testing significant changes right before deploying to production. To build a local Kubernetes cluster you will need to do following: Install minikube Install kubectl Install docker Edit the script/k8s/errbot/secret.yaml.example Rename the file to secret.yaml Add your CHAT_SERVICE_TOKEN as a base64 encoded string . You can use python3 script/base64string.py --string <your-string> to generate a base64 encoded string for the k8s secret Optionally set other secrets or credentials you wish to use in this file and then reference them in the script/k8s/errbot/deployment.yaml file \u26a0\ufe0f Never commit this file as it contains secrets To start a local Kubernetes cluster with minikube, simply run the following command: $ make kube This command will do the following: Start the minikube cluster (if its not already running) Bind Docker to the minikube cluster Build our main errbot image Build our localstack image to mock AWS services (if they are used) Recursively deploy all script/k8s/** manifests to the minikube cluster Once the make kube command has finished, your bot should be running! \ud83c\udf89 Extra Context We use minikube to test Kubernetes changes locally before deploying them to production for extra confidence. For example, if you want to change the resource limits for your errbot container this is something you should certainly test with minikube first. Being able to validate that it \"works locally\" is a great way to ensure you don't accidentally deploy a broken change to production. For this reason, it is highly suggested to build and test locally with minikube for all/any k8s related changes since testing with docker-compose just won't be sufficient. Minikube won't ever be a perfect replication of what is running in production, but the idea is that it is as close as possible to catch any crazy bugs that otherwise would not be caught when developing quickly with docker-compose. Testing It is suggested to write unit tests for your bot in the tests/plugins/ directory. I have personally not done a great job at writing tests for my code, but it is pretty straightforward to write your own tests should you wish to do so: Create a matching file in the tests/plugins/ directory - Ex: tests/plugins/test_meow.py Add some test coverage: pytest_plugins = [\"errbot.backends.test\"] extra_plugin_dir = './src/errbot/plugins' def test_meow(testbot): testbot.push_message('!meow') assert 'meeeeoowww' in testbot.pop_message() Run script/test from the root of the repo to run the test suite That's it! - Obviously a simple example but hopefully you can see how to write your own tests now What's next? Continue on to the helper-functions section to about some helpful functions to use in your bot commands to make life easier.","title":"Development"},{"location":"development/#development","text":"Looking to add a feature, enchance an existing one, or contribute to this bot? You have come to the right place! The first step to contributing to this bot is getting your environment setup. This is covered on the main document under the setup section so make sure you have the prerequisites section checked off before continuing.","title":"Development"},{"location":"development/#understanding-the-bot","text":"Let's understand all the parts of the this repo so we are familiar before we begin","title":"Understanding the Bot"},{"location":"development/#about-the-infrastructure","text":"Here is a high level overview of this project and the software/infrastruce that run this bot: Core: This project uses errbot which is a Python based chatop/chatbot framework errbot and all of its components are built using Docker to create a deployable image We use Terraform and GitHub actions to deploy the Docker image (from our CI/CD pipeline) to Azure AKS (Kubernetes) The Docker image runs in a container in Azure AKS and connects to Discord The bot then listens for commands and responds to them For any commands that require some form of \"state\" we use AWS DynamoDB to store information since containers are ephemeral by design - We use LocalStack to mock AWS when developing locally \ud83d\ude09 We store any configuration as environment variables and secrets as k8s secrets which get injected into the container on boot","title":"About the Infrastructure"},{"location":"development/#project-folderfile-information","text":"What is in each folder? .github/ - Mainly GitHub workflows for actions script/ - Maintenance and automation scripts for working with this project script/k8s/ - Kubernetes deployment scripts for local development script/localstack/ - Files and Dockerfiles related to building the localstack container for development template/ - Template / boilerplate code for new chatops commands terraform/ - Terraform code for deploying errbot resources terraform/aws - AWS related resources terraform/k8s-cluster - The core components of the errbot k8s cluster terraform/k8s - The k8s resources, services, manifests, secrets, etc to get deployed on the k8s-cluster src/ - All the files, data, and configuration for errbot and its related services src/errbot/backend/ - Folder containing extra backend modules (Discord) src/errbot/ - Folder containing all the extra / custom plugins for our chatop commands src/errbot/lib/ - Folder containing shared libraries for plugins What are these files? .gitignore - Used for ignoring files from Git config.env - Used for adding non-sensitive environment variables to your local instance of errbot creds.env - Used for adding sensitive environment variables to your local instance of errbot docker-compose.yml - Used for starting errbot locally with Docker-Compose Makefile - Used to easily invoke scripts in this repo *.md - Documentation! Okay, now let's get started!","title":"Project Folder/File Information"},{"location":"development/#running-the-bot-locally","text":"This should look familiar from the setup section Let's create a local instance of Errbot : $ make local [#] Starting local bot test environment [#] Killing old docker processes docker-compose rm -fs Stopping chatbot ... done Going to remove chatbot Removing chatbot ... done [#] Building docker containers docker-compose build Building chatbot [+] Building 1.3s (22/22) FINISHED [#] TEST Container is now running! [#] Interact with me over the CLI prompt below [@local_admin \u27a1 @errbot] >>> You can now interact with Errbot from the command line! Type a command like .help to get an output of all the commands that are available So what exactly does make local do? docker-compose rm -fs Removes and destroys any errbot_chatbot Docker containers (if running) docker-compose build Rebuilds the errbot_chatbot Docker container and bakes in any new changes you have made. The Docker build packages up components from the src/errbot directory Runs docker run -it --rm --env-file config.env --env-file creds.env -e LOCAL_TESTING=True errbot_chatbot:latest - Let's break this one down.. This starts the errbot_chatbot:latest container in interactive mode ( -it ) Removes the container once you exit the CLI ( --rm ) Uses the config.env file to load non-sensitive environment variables ( --env-file config.env ) Uses the creds.env file to load sensitive environment variables ( --env-file creds.env ) Specifies the LOCAL_TESTING=True environment variable ( -e LOCAL_TESTING=True ) - Used in app/config.py Pops open a CLI prompt when complete for you to interact and issues commands to test and develop errbot Okay, so we started up the bot, hooray! Now lets go over how to create a chatop command","title":"Running the Bot Locally \ud83e\udd16"},{"location":"development/#creating-a-new-chatop-command","text":"Before we create a new chatop command, let's go over it a bit.","title":"Creating a new ChatOp Command \ud83d\udee0\ufe0f"},{"location":"development/#about-chatop-commands","text":"Click to expand each section and learn more about chatops What is a chatop command? .help , .uptime , .whoami , .example are all examples of chatop commands The first three commands listed above ( .help , .uptime , .whoami ) are builtin commands. This means that they come with the errbot framework . The last command listed above ( .example ) is a plugin command. This means that it is a chatop command which we created for our own use! This guide will focus on plugins which are chatops commands that we write and bake into our chatbot. Where are chatop commands stored? They are stored in the src/errbot/plugins folder. Each chatop command is then stored in its own subfolder: src/errbot/example What is the src/errbot/lib folder? Good thing you asked! This is a special folder for storing shared/common libraries between chatop commands. For example, let's say you had two chatop functions .send cat meme and .send dog meme . People were spamming memes too fast so you needed to rate limit both commands. You could add a shared rate_limit_memes() function in src/errbot/lib/common and then import that function into both your cat and dog chatops. Check out the src/errbot/lib folder to see examples in action Okay cool beans, now that we know a bit more about chatops commands, let's create a brand new one","title":"About ChatOp Commands"},{"location":"development/#creating-a-command","text":"At the root of this repo you will notice a template folder. This folder contains the bare minimum code to create a brand new chatop command. Since copying this file from the template folder to the src/errbot/template folder takes about 1 brain cell too many, there is a script to do it for you. Run the following command to copy the template folder into the plugin directory: make command Follow the prompts from this script and create a new command (maybe something like .cat meow ) Making a new command by hand (eww) Enter the `src/errbot/template` folder and poke around the two files you see in there for a bit. In order to make a new chatop command you just need to change a few lines to the new name of you function / functions. Let's say we want to make a new chatop command that responds with some simple text like \"meow\" and it is invoked by typing `.cat meow`. To do so, make the following changes: 1. Change the name of the `src/errbot/template` folder: `src/errbot/template` -> `src/errbot/catmeow` 2. Change the name of the `src/errbot/template/template.plug` file: `src/errbot/template/template.plug` -> `src/errbot/template/catmeow.plug` 3. Change the name of the `src/errbot/template/template.py` file: `src/errbot/template/template.py` -> `src/errbot/template/catmeow.py` 4. Inside of the `src/errbot/template/template.plug` file change all occurrences of `Template` or `template` to `Catmeow` or `catmeow`: Example: `Name = Template # Change me!` -> `Name = Catmeow` Example: `Module = template # Change me!` -> `Module = catmeow` > Note the cases of T/t and C/c above 5. Inside of the `src/errbot/template/template.py` file change the class name: `class Template(BotPlugin): # Change me!` -> `class Catmeow(BotPlugin):` 6. Inside of the `src/errbot/template/template.py` file change the function name: `def template(self, msg, args): # Change me! (function name)` -> `def cat_meow(self, msg, args):` > Note: We use `_` (underscores) in function names to represent spaces in our command. `def cat_meow(...)` becomes `.cat meow` via the chatop 7. To make the `.cat meow` command return something, edit the return message: `return 'Hello world, I am a template!'` -> `return 'meow!'` Once you follow through all the prompts from the script, you should have a new folder in src/errbot/plugins/<new-command-name> Open up the Python file in that directory to add some code. It will be a template for you to edit and bring your .cat meow command to life. I will include a snippet below of what it could look like: from errbot import BotPlugin, botcmd class CatMeow(BotPlugin): \"\"\"A chat command that sends cat noises\"\"\" @botcmd def cat_meow(self, msg, args): \"\"\"Makes a cat noise\"\"\" return \"meeeeoowww\" Let's break down what each line of the snippet above does: from errbot import BotPlugin, botcmd # Imports the errbot plugins and decorators to make a function into a bot command class CatMeow(BotPlugin): # Creates a new class for all our Cat related bot commands. # A class can contain many or just a single bot command @botcmd # The mighty bot decorator that turns the function into a bot command! def cat_meow(self, msg, args): # The bot command (more info below this code snippet) \"\"\"Makes a cat noise\"\"\" # A docstring that can be viewed via the bot's 'help' command return \"meeeeoowww\" # The String which the bot returns when invoked for this bot command The Bot Command : In the snippet above, the line def cat_meow(self, msg, args) has a lot to unpack. This function has a decorator applied to it that turns it into a bot command. During run time, the BOT_PREFIX from the config.env file (in the root of this repo) get applied to the front of the function name and all _ (underscores) become spaces. So cat_meow ultimately becomes !cat meow as a bot command for example. self , msg , and args are all required errbot params for this function to work. To see what attributes these objects contain I would suggest looking at src/errbot/plugins/example/example.py or taking a deeper looking into the official errbot documentation . Okay, that's enough of that.. let's start the bot and test out our new .cat meow command! To test, cd to the root of this repo and run make local . Your new plugin should be loaded and you can interact with it via the CLI: Note: I use . to invoke my bot but that is ultimately determined on what you have you BOT_PREFIX set to in the config.env file. [@local_admin \u27a1 @errbot] >>> .cat meow meeeeoowww","title":"Creating a command"},{"location":"development/#linting-your-code","text":"This section is specific to the GrantBirki/errbot repo for the CI/CD pipeline and to adhear to code linting standards in this repo In order for CI to pass, you must have properly linted code. Luckily, this is extremely easy to do and can be performed in a single command: $ script/lint All done! \u2728 \ud83c\udf70 \u2728 1 file reformatted, 14 files left unchanged. That's it! This will lint all *.py files in the repo to ensure they conform to the Black linting guidelines Linting is just the formatting of your code to a certain standard (ie: no trailing whitespaces, \"\" quotes instead of '', etc)","title":"Linting your code"},{"location":"development/#kubernetes","text":"So far, in these docs we have been using docker-compose to run the bot. This is great for testing and development but it is not ideal for production or testing changes right before deploying to production. Like most containerized applications, Kubernetes is a great option. Kubernetes is what I use personally to deploy this bot. In order to closely mimic the docker-compose setup and the production Kubernetes setup we can use minikube to bridge the two together. Note: docker-compose is still the suggested method for developing locally because it is easier and quicker to test changes. Kubernetes is best suited for testing significant changes right before deploying to production. To build a local Kubernetes cluster you will need to do following: Install minikube Install kubectl Install docker Edit the script/k8s/errbot/secret.yaml.example Rename the file to secret.yaml Add your CHAT_SERVICE_TOKEN as a base64 encoded string . You can use python3 script/base64string.py --string <your-string> to generate a base64 encoded string for the k8s secret Optionally set other secrets or credentials you wish to use in this file and then reference them in the script/k8s/errbot/deployment.yaml file \u26a0\ufe0f Never commit this file as it contains secrets To start a local Kubernetes cluster with minikube, simply run the following command: $ make kube This command will do the following: Start the minikube cluster (if its not already running) Bind Docker to the minikube cluster Build our main errbot image Build our localstack image to mock AWS services (if they are used) Recursively deploy all script/k8s/** manifests to the minikube cluster Once the make kube command has finished, your bot should be running! \ud83c\udf89","title":"Kubernetes"},{"location":"development/#extra-context","text":"We use minikube to test Kubernetes changes locally before deploying them to production for extra confidence. For example, if you want to change the resource limits for your errbot container this is something you should certainly test with minikube first. Being able to validate that it \"works locally\" is a great way to ensure you don't accidentally deploy a broken change to production. For this reason, it is highly suggested to build and test locally with minikube for all/any k8s related changes since testing with docker-compose just won't be sufficient. Minikube won't ever be a perfect replication of what is running in production, but the idea is that it is as close as possible to catch any crazy bugs that otherwise would not be caught when developing quickly with docker-compose.","title":"Extra Context"},{"location":"development/#testing","text":"It is suggested to write unit tests for your bot in the tests/plugins/ directory. I have personally not done a great job at writing tests for my code, but it is pretty straightforward to write your own tests should you wish to do so: Create a matching file in the tests/plugins/ directory - Ex: tests/plugins/test_meow.py Add some test coverage: pytest_plugins = [\"errbot.backends.test\"] extra_plugin_dir = './src/errbot/plugins' def test_meow(testbot): testbot.push_message('!meow') assert 'meeeeoowww' in testbot.pop_message() Run script/test from the root of the repo to run the test suite That's it! - Obviously a simple example but hopefully you can see how to write your own tests now","title":"Testing"},{"location":"development/#whats-next","text":"Continue on to the helper-functions section to about some helpful functions to use in your bot commands to make life easier.","title":"What's next?"},{"location":"discord-turbo-quickstart/","text":"Discord Turbo Quickstart This doc is an extremely simplified guide to start your bot and connect it to Discord when testing locally Shortest possible docs for the process: Clone this repo Rename the creds.env.example file to creds.env Add your Discord bot token -> CHAT_SERVICE_TOKEN='<value>' Run make run from the terminal Invite your bot to your Discord server \ud83d\ude80 What's next? To learn more about developing your bot, adding custom plugins, and more, check out the more in-depth development guide !","title":"Discord Turbo Quickstart"},{"location":"discord-turbo-quickstart/#discord-turbo-quickstart","text":"This doc is an extremely simplified guide to start your bot and connect it to Discord when testing locally Shortest possible docs for the process: Clone this repo Rename the creds.env.example file to creds.env Add your Discord bot token -> CHAT_SERVICE_TOKEN='<value>' Run make run from the terminal Invite your bot to your Discord server \ud83d\ude80","title":"Discord Turbo Quickstart"},{"location":"discord-turbo-quickstart/#whats-next","text":"To learn more about developing your bot, adding custom plugins, and more, check out the more in-depth development guide !","title":"What's next?"},{"location":"helper-functions/","text":"Helper Functions This guide contains details around a few helper functions that can be used to enhance the functionality of your chatbot functions. What is a helper function? A helper function is anything we consider a utility, helper, or shared library that can enhance chat functions. This is code that can be reused in multiple chat functions as well. Where are the helper functions located? All helper functions, libraries, and general utilities are stored in the src/errbot/plugins/lib folder. Subdirs: chat : Helper functions specific to chat services such as Discord, Slack, etc. common : Common functions that can be used all over the place. Stuff like datetime formatting, logging, hashes, searching, etc database : Helper functions for database operations (specifically for DynamoDB) Top Helper Functions \u2b50 There are a few helper functions that are super useful for the bot and will be used in most functions. There will be details about these functions below but the rest you will need to dig into the src/errbot/plugins/lib and read the doc strings to understand how they work. Note: All examples below will be using the basic bot command template from the main README.md from this repo Server Lock Certain bot commands can and will be locked to servers. Whether for testing, privacy or security reasons you may want to lock certain commands to a specific server. This can be accomplished by using the SERVER_LOCK_ALLOW_LIST='123456789,987654321' environment variable which can be set in the config.env file. First, check out that file to see the comments with more details around the environment variable. To actually use the environement variable in conjunction the lock function and a bot function to \"lock\" you need to add the helper method to a bot command: from errbot import BotPlugin, botcmd from lib.chat.chatutils import ChatUtils # import the ChatUtils lib chatutils = ChatUtils() # create a ChatUtils object class Hello(BotPlugin): \"\"\"Example 'Hello, world!' plugin for Errbot\"\"\" @botcmd def hello(self, msg, args): \"\"\"Return the phrase \"Hello, world!\" in chat\"\"\" # check if the command is server locked - True means that it is locked and NOT in the allow list if chatutils.locked(msg, self): # since it is locked, we immediately exit the bot function and do not continue! return return \"Hello, world!\" The msg variable in def hello(self, msg, args) contains a Discord server id that will be checked against the SERVER_LOCK_ALLOW_LIST environment variable. If chatutils.locked(msg, self) returns True, it means that the lock is enabled and the command is not allowed to be executed. It will automatically return a message like the one below to the user who invoked the command from a server that is not in the allow list: If the user invoked the command from a server that is in the allow list, the command will execute normally. ErrHelper The ErrHelper library is a very important library in terms of logging and error reporting. If the SENTRY environment variable is configured properly in the creds.env file, then this library is used to send exception reports to Sentry automatically. There is also a few helper functions available in this library that can be very useful in chat functions: Manually send an exception report to Sentry (ex: after capturing an exception with try/except) Get the current user context for better insights with Sentry (ex: get the user's username, id, etc) To learn more about the ErrHelper library before looking at the example below, check out the source code: src/errbot/plugins/lib/common/errhelper.py from errbot import BotPlugin, botcmd from lib.common.errhelper import ErrHelper # import the ErrHelper lib class Hello(BotPlugin): \"\"\"Example 'Hello, world!' plugin for Errbot\"\"\" @botcmd def hello(self, msg, args): \"\"\"Return the phrase \"Hello, world!\" in chat\"\"\" ErrHelper().user(msg) # set the user context (do this right at the top of the function before anything else) # optional example demonstrating how to send an exception report to Sentry manually try: # do something that might throw an exception raise Exception(\"This is an example exception\") except Exception as error: # send the exception to Sentry ErrHelper().capture(error) return \"Hello, world!\" You should add the ErrHelper().user(msg) line to the very top of every single @botcmd function as this provides meaningful context to all exceptions that can/will occur eventually in your function \ud83d\ude04 What's next? Continue on to the persistence section to learn more about how to have a level of persistence with your bot in the ephemeral container world \ud83d\udcbe Alternatively, continue on to the deployment section to learn more about how to deploy your bot to production \ud83d\ude80","title":"Helper Functions"},{"location":"helper-functions/#helper-functions","text":"This guide contains details around a few helper functions that can be used to enhance the functionality of your chatbot functions.","title":"Helper Functions"},{"location":"helper-functions/#what-is-a-helper-function","text":"A helper function is anything we consider a utility, helper, or shared library that can enhance chat functions. This is code that can be reused in multiple chat functions as well.","title":"What is a helper function?"},{"location":"helper-functions/#where-are-the-helper-functions-located","text":"All helper functions, libraries, and general utilities are stored in the src/errbot/plugins/lib folder. Subdirs: chat : Helper functions specific to chat services such as Discord, Slack, etc. common : Common functions that can be used all over the place. Stuff like datetime formatting, logging, hashes, searching, etc database : Helper functions for database operations (specifically for DynamoDB)","title":"Where are the helper functions located?"},{"location":"helper-functions/#top-helper-functions","text":"There are a few helper functions that are super useful for the bot and will be used in most functions. There will be details about these functions below but the rest you will need to dig into the src/errbot/plugins/lib and read the doc strings to understand how they work. Note: All examples below will be using the basic bot command template from the main README.md from this repo","title":"Top Helper Functions \u2b50"},{"location":"helper-functions/#server-lock","text":"Certain bot commands can and will be locked to servers. Whether for testing, privacy or security reasons you may want to lock certain commands to a specific server. This can be accomplished by using the SERVER_LOCK_ALLOW_LIST='123456789,987654321' environment variable which can be set in the config.env file. First, check out that file to see the comments with more details around the environment variable. To actually use the environement variable in conjunction the lock function and a bot function to \"lock\" you need to add the helper method to a bot command: from errbot import BotPlugin, botcmd from lib.chat.chatutils import ChatUtils # import the ChatUtils lib chatutils = ChatUtils() # create a ChatUtils object class Hello(BotPlugin): \"\"\"Example 'Hello, world!' plugin for Errbot\"\"\" @botcmd def hello(self, msg, args): \"\"\"Return the phrase \"Hello, world!\" in chat\"\"\" # check if the command is server locked - True means that it is locked and NOT in the allow list if chatutils.locked(msg, self): # since it is locked, we immediately exit the bot function and do not continue! return return \"Hello, world!\" The msg variable in def hello(self, msg, args) contains a Discord server id that will be checked against the SERVER_LOCK_ALLOW_LIST environment variable. If chatutils.locked(msg, self) returns True, it means that the lock is enabled and the command is not allowed to be executed. It will automatically return a message like the one below to the user who invoked the command from a server that is not in the allow list: If the user invoked the command from a server that is in the allow list, the command will execute normally.","title":"Server Lock"},{"location":"helper-functions/#errhelper","text":"The ErrHelper library is a very important library in terms of logging and error reporting. If the SENTRY environment variable is configured properly in the creds.env file, then this library is used to send exception reports to Sentry automatically. There is also a few helper functions available in this library that can be very useful in chat functions: Manually send an exception report to Sentry (ex: after capturing an exception with try/except) Get the current user context for better insights with Sentry (ex: get the user's username, id, etc) To learn more about the ErrHelper library before looking at the example below, check out the source code: src/errbot/plugins/lib/common/errhelper.py from errbot import BotPlugin, botcmd from lib.common.errhelper import ErrHelper # import the ErrHelper lib class Hello(BotPlugin): \"\"\"Example 'Hello, world!' plugin for Errbot\"\"\" @botcmd def hello(self, msg, args): \"\"\"Return the phrase \"Hello, world!\" in chat\"\"\" ErrHelper().user(msg) # set the user context (do this right at the top of the function before anything else) # optional example demonstrating how to send an exception report to Sentry manually try: # do something that might throw an exception raise Exception(\"This is an example exception\") except Exception as error: # send the exception to Sentry ErrHelper().capture(error) return \"Hello, world!\" You should add the ErrHelper().user(msg) line to the very top of every single @botcmd function as this provides meaningful context to all exceptions that can/will occur eventually in your function \ud83d\ude04","title":"ErrHelper"},{"location":"helper-functions/#whats-next","text":"Continue on to the persistence section to learn more about how to have a level of persistence with your bot in the ephemeral container world \ud83d\udcbe Alternatively, continue on to the deployment section to learn more about how to deploy your bot to production \ud83d\ude80","title":"What's next?"},{"location":"observability/","text":"Observability This section will describe the observability components that this project uses out of the bot to track things like command usage, central logging, and more. Tech Stack The tech stack used for log collection is as follows: Promtail Loki Grafana If you are unfamiliar with how a Grafana stack works I would highly suggest reading up about it because it can be a very powerful tool and all the components used are open-source. A very short description of how this project uses the stack (listed above) is as follows: Promtail scrapes the logs from the bot and pushes them to a Loki instance Loki aggregates the log streams and tags them Grafana uses Loki as a data source to graph, visualize, and query the logs that the bot generates Using the Log Stack Since this bot can be built and tested in a variety of ways, the logging tech stack also can be setup in a variety of ways. Here is a description of how the logging tech stack can be setup in the different environments: make local : Uses no logging stack at all make run : Starts the bot using docker-compose. Builds the full stack as seperate containers running on the same docker network (see docker-compose section below as the stack components need to be enabled first) make kube : Starts the bot in minikube with no logging stack initially. After the minikube cluster has been started, you have two options for starting your logging stack: script/k8s/obervability/setup : Starts the logging stack inside of your minikube cluster ( make kube must be run first) Manually apply the script/k8s/obervability/*.yaml.* files to your minikube cluster and make sure to edit them as needed (specifcally the config map file to point to your Loki instance). This option is more complex and allows you to point your minikube cluster to a different Loki instance such as Grafana cloud. In production, the bot ships logs to Grafana cloud ( make kube must be run first) docker-compose Since the observability stack isn't really useful for average local development it is disabled by default. To enable the logging stack with docker-compose and have it start up with your bot container when using make run , simply go into the docker-compose.yml file and uncomment the obervability section, and the volume section for the main errbot container. You will see in-line comments instructing you which lines to enable. Once you are done, run make run and your whole logging stack will start! Once the docker-compose stack starts, you can navigate to localhost:3000/login to get to your Grafana dashboard Username: admin Password: admin The Loki data source is automatically configured so you can go straight to browsing your bot's logs! minikube In minikube and in production, we use a daemonset in Kubernetes . This allows us to scrape and collect all logs on the node with promtail and then push them to our defined Loki instance. The observability stack is also disabled by default in minikube but it can be easily enabled with a single command: $ script/k8s/observability/setup This will apply all the necessary k8s manifests to your minikube cluster to enable the observability stack. Next, run the command below in a separate terminal window: $ kubectl port-forward --namespace observability service/loki-grafana 3000:80 Now you can navigate to localhost:3000/login to get to your Grafana dashboard Username: admin Password: <displayed to you in the 'script/k8s/observability/setup' script's output> Note: If you need to get your Grafana password again, you can run kubectl get secret --namespace observability loki-grafana -o jsonpath=\"{.data.admin-password}\" | base64 --decode ; echo Grafana Screenshots \ud83d\udcf8","title":"Observability"},{"location":"observability/#observability","text":"This section will describe the observability components that this project uses out of the bot to track things like command usage, central logging, and more.","title":"Observability"},{"location":"observability/#tech-stack","text":"The tech stack used for log collection is as follows: Promtail Loki Grafana If you are unfamiliar with how a Grafana stack works I would highly suggest reading up about it because it can be a very powerful tool and all the components used are open-source. A very short description of how this project uses the stack (listed above) is as follows: Promtail scrapes the logs from the bot and pushes them to a Loki instance Loki aggregates the log streams and tags them Grafana uses Loki as a data source to graph, visualize, and query the logs that the bot generates","title":"Tech Stack"},{"location":"observability/#using-the-log-stack","text":"Since this bot can be built and tested in a variety of ways, the logging tech stack also can be setup in a variety of ways. Here is a description of how the logging tech stack can be setup in the different environments: make local : Uses no logging stack at all make run : Starts the bot using docker-compose. Builds the full stack as seperate containers running on the same docker network (see docker-compose section below as the stack components need to be enabled first) make kube : Starts the bot in minikube with no logging stack initially. After the minikube cluster has been started, you have two options for starting your logging stack: script/k8s/obervability/setup : Starts the logging stack inside of your minikube cluster ( make kube must be run first) Manually apply the script/k8s/obervability/*.yaml.* files to your minikube cluster and make sure to edit them as needed (specifcally the config map file to point to your Loki instance). This option is more complex and allows you to point your minikube cluster to a different Loki instance such as Grafana cloud. In production, the bot ships logs to Grafana cloud ( make kube must be run first)","title":"Using the Log Stack"},{"location":"observability/#docker-compose","text":"Since the observability stack isn't really useful for average local development it is disabled by default. To enable the logging stack with docker-compose and have it start up with your bot container when using make run , simply go into the docker-compose.yml file and uncomment the obervability section, and the volume section for the main errbot container. You will see in-line comments instructing you which lines to enable. Once you are done, run make run and your whole logging stack will start! Once the docker-compose stack starts, you can navigate to localhost:3000/login to get to your Grafana dashboard Username: admin Password: admin The Loki data source is automatically configured so you can go straight to browsing your bot's logs!","title":"docker-compose"},{"location":"observability/#minikube","text":"In minikube and in production, we use a daemonset in Kubernetes . This allows us to scrape and collect all logs on the node with promtail and then push them to our defined Loki instance. The observability stack is also disabled by default in minikube but it can be easily enabled with a single command: $ script/k8s/observability/setup This will apply all the necessary k8s manifests to your minikube cluster to enable the observability stack. Next, run the command below in a separate terminal window: $ kubectl port-forward --namespace observability service/loki-grafana 3000:80 Now you can navigate to localhost:3000/login to get to your Grafana dashboard Username: admin Password: <displayed to you in the 'script/k8s/observability/setup' script's output> Note: If you need to get your Grafana password again, you can run kubectl get secret --namespace observability loki-grafana -o jsonpath=\"{.data.admin-password}\" | base64 --decode ; echo","title":"minikube"},{"location":"observability/#grafana-screenshots","text":"","title":"Grafana Screenshots \ud83d\udcf8"},{"location":"persistence/","text":"Persistence This is a more advanced topic. This article will not fully show you how to setup persistence but rather plant some seeds for how you can do it on your own \ud83c\udf31 (and hopefully help you get there) The very nature of containers is ephemeral and persistence is always a valid question when it comes to containers. For this project I chose to lean pretty hard into AWS DynamoDB to save small bits of state where needed. The bot itself is fairly stateless and all its configuration is baked in via environement variables. However, certain bot commands have statistics tied into them, they can remember things, and have leader boards. In order to retain this data, nosql records are stored in various DynamoDB tables. Walkthrough This section will walk through an example of a bot commad that has persistence and I will do the best I can to explain how this is stored in DynamoDB: Note: This examples uses a \"top down approach\". You will first \"see\" a chat command being run and then run through all the pieces it interacts with and you will end with the initial table creation via Terraform A user invokes the .remember command to remember something simple: text .remember meeting is tomorrow This will write a record to DynamoDB with meeting as the key and tomorrow as the value Here is an example of some code that could write these values to DynamoDB: python from lib.database.dynamo_tables import RememberTable dynamo = Dynamo() dynamo.write( RememberTable( discord_server_id=guild_id, rem_key=result[\"key\"], rem_value=result[\"value\"], ) ) Check out the src/errbot/plugins/database/dynamo_tables.py file to see where the structure for tables can be defined Check out the src/errbot/plugins/database/dynamo.py file to see where I implemented a helper class for interacting with DynamoDB (as used above in the snippet) Check out the terraform/aws/dynamoDB_tables.tf file to see how DynamoDB tables are created in AWS via Terraform Testing Persistence Locally The docker-compose.yml files comes with a side car container running localstack which is a growing project that does a good job at \"mocking\" many core AWS services. One of these services is DynamoDB and works quite well for testing locally. When you run make run it automatically launches a localstack container with DynamoDB enabled. When the localstack container starts up, it will run the script\\localstack\\localstack-startup script which will pre-populate many DynamoDB tables for local testing. This is rather helpful because you can test out your persistence features locally to determine if it is worth the effort to setup something like AWS DynamoDB to hold state records for your bot. Note: By using the localstack side car container, you will be able to test out chat commands that need persistence like .remember , .play stats , etc. Whoot! Summary The main take-aways from this section is that this bot comes with some built in commands that have a level of persistence to them. If you want these command to function properly or if you want to develop your own commands in the future that are stateful, you will need to enable a form of persistence for your bot. I have shown you one method of doing so with AWS DynamoDB but there are many more options so chose what works best for you \ud83d\ude03","title":"Persistence"},{"location":"persistence/#persistence","text":"This is a more advanced topic. This article will not fully show you how to setup persistence but rather plant some seeds for how you can do it on your own \ud83c\udf31 (and hopefully help you get there) The very nature of containers is ephemeral and persistence is always a valid question when it comes to containers. For this project I chose to lean pretty hard into AWS DynamoDB to save small bits of state where needed. The bot itself is fairly stateless and all its configuration is baked in via environement variables. However, certain bot commands have statistics tied into them, they can remember things, and have leader boards. In order to retain this data, nosql records are stored in various DynamoDB tables.","title":"Persistence"},{"location":"persistence/#walkthrough","text":"This section will walk through an example of a bot commad that has persistence and I will do the best I can to explain how this is stored in DynamoDB: Note: This examples uses a \"top down approach\". You will first \"see\" a chat command being run and then run through all the pieces it interacts with and you will end with the initial table creation via Terraform A user invokes the .remember command to remember something simple: text .remember meeting is tomorrow This will write a record to DynamoDB with meeting as the key and tomorrow as the value Here is an example of some code that could write these values to DynamoDB: python from lib.database.dynamo_tables import RememberTable dynamo = Dynamo() dynamo.write( RememberTable( discord_server_id=guild_id, rem_key=result[\"key\"], rem_value=result[\"value\"], ) ) Check out the src/errbot/plugins/database/dynamo_tables.py file to see where the structure for tables can be defined Check out the src/errbot/plugins/database/dynamo.py file to see where I implemented a helper class for interacting with DynamoDB (as used above in the snippet) Check out the terraform/aws/dynamoDB_tables.tf file to see how DynamoDB tables are created in AWS via Terraform","title":"Walkthrough"},{"location":"persistence/#testing-persistence-locally","text":"The docker-compose.yml files comes with a side car container running localstack which is a growing project that does a good job at \"mocking\" many core AWS services. One of these services is DynamoDB and works quite well for testing locally. When you run make run it automatically launches a localstack container with DynamoDB enabled. When the localstack container starts up, it will run the script\\localstack\\localstack-startup script which will pre-populate many DynamoDB tables for local testing. This is rather helpful because you can test out your persistence features locally to determine if it is worth the effort to setup something like AWS DynamoDB to hold state records for your bot. Note: By using the localstack side car container, you will be able to test out chat commands that need persistence like .remember , .play stats , etc. Whoot!","title":"Testing Persistence Locally"},{"location":"persistence/#summary","text":"The main take-aways from this section is that this bot comes with some built in commands that have a level of persistence to them. If you want these command to function properly or if you want to develop your own commands in the future that are stateful, you will need to enable a form of persistence for your bot. I have shown you one method of doing so with AWS DynamoDB but there are many more options so chose what works best for you \ud83d\ude03","title":"Summary"},{"location":"setup/","text":"Setup This guide will walk you through setting up errbot for local development \ud83d\udd28 Project Components Key concepts : There are three main components to errbot: The chatbot itself - This is errbot , the python app running in a docker container which processes requests - src/errbot/ The chat-service - This is what you are connecting your chatbot to. This could be Discord, Slack, etc.. I will be using Discord for this guide but Slack is also tested and works fine. The database - This could be literally anything to store state since the nature of containers is ephimeral. For this project I have chosen AWS DynamoDB for state storage. When testing locally I use LocalStack to mock AWS DynamoDB. Prerequisites If you got all the items below downloaded and are familiar with setting up a bot account for your chat service (Slack, Discord, etc), you can skip right to the usage section. Docker Docker-compose Make WSL if you are using Windows Python Dependencies for testing ( pip install -r requirements.txt ) Depending on which \"backend\" or \"chat-service\" you plan on using, you will need an authentication token to start your bot. Slack - Extra errbot documentation Discord - Extra errbot documentation Lastly, you will need to be familiar with how to add your bot to your chat service. Adding your bot to a chat service examples: Slack In the case of Slack, this can be done by mentioning your bot in any channel and you will be prompted to invite the bot right there. Note, this particular repo leans towards Discord for most things. However, as of this writing, all features of this bot work in Slack as well with the exception of having the bot join a voice channel as that is not a feature of Slack.. yet Discord This bot has already been provisioned to Discord. It is included as a reference should the bot ever need to be rebuilt With Discord, things are a little different. You will need to first enable SERVER MEMBERS INTENT for your bot application. After that, you need to go into the Oauth2 page for your bot and select the bot scope. This will expand more options. You may go as crazy or as restrictive as you want with the chat permissions. That part is totally up to you. Once your permissiosn are scoped out, you will need to copy the oauth2 link that is generated. It could look something like this: https://discord.com/api/oauth2/authorize?client_id=<number>&permissions=<number>&scope=bot Note: You can find an example invite link farther below Enter that link into your web browser and it should give you a list of servers to invite your bot to. Add it to your favorite server! To setup your bot, you will need to modify your config.env file. To make things easier, there is a config.example.env file in the root of this repo. Rename config.example.env to config.env *required Set BACKEND=<backend> *required Set CHAT_SERVICE_TOKEN='<token>' *required Change BOT_PREFIX='!' if you want *optional Usage - Locally Important : Make sure you followed the setup instructions above first For plugin testing and running the bot locally, you may run the following command to launch a local instance of your bot and interact with it over the command line: $ make local [#] Starting local bot test environment [#] Killing old docker processes docker-compose rm -fs Stopping chatbot ... done Going to remove chatbot Removing chatbot ... done [#] Building docker containers docker-compose build Building chatbot [+] Building 1.3s (22/22) FINISHED ... .. . [#] TEST Container is now running! [#] Interact with me over the CLI prompt below ... .. . [@local_admin \u27a1 @errbot] >>> Note : You may notice some errors in your output. This is expected if you do not have all the proper credentials setup in your creds.env file. For example, if you have an API token that is needed for a plugin, and that token is not present in the environment, that plugin will fail to load. All others should load fine and you can test normally. Read more about the errbot local dev environment here Windows Tips for Local Usage If for some reason you are using Windows and not WSL, you can build a local image using the following commands: $ docker-compose build [+] Building 1.3s (22/22) FINISHED $ docker run -it --rm --env-file config.env --env-file creds.env -e LOCAL_TESTING=True errbot_chatbot:latest This will result in a CLI prompt to errbot locally so you can test. Simply press CTRL+C to exit when you are done Usage - Connected to a Chat Service Completed the simple setup locally? Awesome! Let's start the bot connected to a live chat service: Note: make run will start the bot and attach it to Discord (or another chat service) for usage. If you are looking to start a local instance of the bot, see the Usage - Locally section earlier in this guide $ make run [#] Killing old docker processes docker-compose rm -fs No stopped containers [#] Building docker containers docker-compose up --build -d Building chatbot [+] Building 1.3s (23/23) FINISHED Creating chatbot ... done [#] Container is now running! Note: for security reasons the creds.env file is not committed to this repo and NEVER should be. If you followed the steps above and everything succeeded, you should get a DM from the bot stating that it is \"Now Online\". You should note that you will only get this message if BOT_ADMINS='@username' is set to your username in the config.env file. Note x2: Running make run will start the errbot-dev bot and can be invoked with ! rather than the usual . . You can tweak this however you like with the BOT_PREFIX env var That's it for the setup! If you followed the instructions above, your Docker container should start and most plugins should load correctly. Certain plugins like the league plugin require an API key so those will fail until that environment variable is provided but this is expected. All this and more will be covered in the next section! What's next? Continue on to the configuration section to learn how you can configure your bot to your preferences before you start development.","title":"Setup"},{"location":"setup/#setup","text":"This guide will walk you through setting up errbot for local development \ud83d\udd28","title":"Setup"},{"location":"setup/#project-components","text":"Key concepts : There are three main components to errbot: The chatbot itself - This is errbot , the python app running in a docker container which processes requests - src/errbot/ The chat-service - This is what you are connecting your chatbot to. This could be Discord, Slack, etc.. I will be using Discord for this guide but Slack is also tested and works fine. The database - This could be literally anything to store state since the nature of containers is ephimeral. For this project I have chosen AWS DynamoDB for state storage. When testing locally I use LocalStack to mock AWS DynamoDB.","title":"Project Components"},{"location":"setup/#prerequisites","text":"If you got all the items below downloaded and are familiar with setting up a bot account for your chat service (Slack, Discord, etc), you can skip right to the usage section. Docker Docker-compose Make WSL if you are using Windows Python Dependencies for testing ( pip install -r requirements.txt ) Depending on which \"backend\" or \"chat-service\" you plan on using, you will need an authentication token to start your bot. Slack - Extra errbot documentation Discord - Extra errbot documentation Lastly, you will need to be familiar with how to add your bot to your chat service. Adding your bot to a chat service examples:","title":"Prerequisites"},{"location":"setup/#slack","text":"In the case of Slack, this can be done by mentioning your bot in any channel and you will be prompted to invite the bot right there. Note, this particular repo leans towards Discord for most things. However, as of this writing, all features of this bot work in Slack as well with the exception of having the bot join a voice channel as that is not a feature of Slack.. yet","title":"Slack"},{"location":"setup/#discord","text":"This bot has already been provisioned to Discord. It is included as a reference should the bot ever need to be rebuilt With Discord, things are a little different. You will need to first enable SERVER MEMBERS INTENT for your bot application. After that, you need to go into the Oauth2 page for your bot and select the bot scope. This will expand more options. You may go as crazy or as restrictive as you want with the chat permissions. That part is totally up to you. Once your permissiosn are scoped out, you will need to copy the oauth2 link that is generated. It could look something like this: https://discord.com/api/oauth2/authorize?client_id=<number>&permissions=<number>&scope=bot Note: You can find an example invite link farther below Enter that link into your web browser and it should give you a list of servers to invite your bot to. Add it to your favorite server! To setup your bot, you will need to modify your config.env file. To make things easier, there is a config.example.env file in the root of this repo. Rename config.example.env to config.env *required Set BACKEND=<backend> *required Set CHAT_SERVICE_TOKEN='<token>' *required Change BOT_PREFIX='!' if you want *optional","title":"Discord"},{"location":"setup/#usage-locally","text":"Important : Make sure you followed the setup instructions above first For plugin testing and running the bot locally, you may run the following command to launch a local instance of your bot and interact with it over the command line: $ make local [#] Starting local bot test environment [#] Killing old docker processes docker-compose rm -fs Stopping chatbot ... done Going to remove chatbot Removing chatbot ... done [#] Building docker containers docker-compose build Building chatbot [+] Building 1.3s (22/22) FINISHED ... .. . [#] TEST Container is now running! [#] Interact with me over the CLI prompt below ... .. . [@local_admin \u27a1 @errbot] >>> Note : You may notice some errors in your output. This is expected if you do not have all the proper credentials setup in your creds.env file. For example, if you have an API token that is needed for a plugin, and that token is not present in the environment, that plugin will fail to load. All others should load fine and you can test normally. Read more about the errbot local dev environment here","title":"Usage - Locally"},{"location":"setup/#windows-tips-for-local-usage","text":"If for some reason you are using Windows and not WSL, you can build a local image using the following commands: $ docker-compose build [+] Building 1.3s (22/22) FINISHED $ docker run -it --rm --env-file config.env --env-file creds.env -e LOCAL_TESTING=True errbot_chatbot:latest This will result in a CLI prompt to errbot locally so you can test. Simply press CTRL+C to exit when you are done","title":"Windows Tips for Local Usage"},{"location":"setup/#usage-connected-to-a-chat-service","text":"Completed the simple setup locally? Awesome! Let's start the bot connected to a live chat service: Note: make run will start the bot and attach it to Discord (or another chat service) for usage. If you are looking to start a local instance of the bot, see the Usage - Locally section earlier in this guide $ make run [#] Killing old docker processes docker-compose rm -fs No stopped containers [#] Building docker containers docker-compose up --build -d Building chatbot [+] Building 1.3s (23/23) FINISHED Creating chatbot ... done [#] Container is now running! Note: for security reasons the creds.env file is not committed to this repo and NEVER should be. If you followed the steps above and everything succeeded, you should get a DM from the bot stating that it is \"Now Online\". You should note that you will only get this message if BOT_ADMINS='@username' is set to your username in the config.env file. Note x2: Running make run will start the errbot-dev bot and can be invoked with ! rather than the usual . . You can tweak this however you like with the BOT_PREFIX env var That's it for the setup! If you followed the instructions above, your Docker container should start and most plugins should load correctly. Certain plugins like the league plugin require an API key so those will fail until that environment variable is provided but this is expected. All this and more will be covered in the next section!","title":"Usage - Connected to a Chat Service"},{"location":"setup/#whats-next","text":"Continue on to the configuration section to learn how you can configure your bot to your preferences before you start development.","title":"What's next?"},{"location":"skaffold/","text":"Skaffold Running the project with skaffold Prerequisites Before you can get going with skaffold you need to edit one file first to add your bot token Obtain a bot token from your chat service (Discord, Slack, etc) base64 encode the token so it can be saved as a k8s secret python3 script/base64string.py --string supersecretvalue From the root of this repo, edit the following file: script/k8s/errbot/secret.yaml.example Add your base64 encoded bot token to the file like so: CHAT_SERVICE_TOKEN: \"base64encodedvaluehere==\" Rename the file to secret.yaml \u26a0\ufe0f Ensure you don't commit this file as it has your secret token! Steps Start your minikube cluster, configure skaffold, and set your Docker context: minikube start --profile custom skaffold config set --global local-cluster true eval $(minikube -p custom docker-env) Start your cluster with skaffold: skaffold dev Optionally, run skaffold dev --tail=true to attach to your running containers to view log output while they run Minikube Dashboard The first thing you may want to do is connect to your minikube instance via the dashboard UI. Enable the k8s dashboard by running the following command in a seperate terminal window: minikube dashboard --profile custom Grafana Now that your cluster is up and running, you can get to your Grafana instance for metrics, logs, etc by doing the following: Open a new terminal window Obtain your Grafana password (the username will be admin ): kubectl get secret --namespace observability grafana -o jsonpath=\"{.data.admin-password}\" | base64 --decode ; echo Port forward to your grafana instance: kubectl port-forward --namespace observability service/grafana 3000:80 If your IDE does not automatically direct you, simply go to http://127.0.0.1:3000/login after port forwarding with kubectl Sign in with the credentials obtained in step two and navigate to the explore tab in Grafana Run a query like the one below to view your errbot container logs in real time!","title":"Skaffold"},{"location":"skaffold/#skaffold","text":"Running the project with skaffold","title":"Skaffold"},{"location":"skaffold/#prerequisites","text":"Before you can get going with skaffold you need to edit one file first to add your bot token Obtain a bot token from your chat service (Discord, Slack, etc) base64 encode the token so it can be saved as a k8s secret python3 script/base64string.py --string supersecretvalue From the root of this repo, edit the following file: script/k8s/errbot/secret.yaml.example Add your base64 encoded bot token to the file like so: CHAT_SERVICE_TOKEN: \"base64encodedvaluehere==\" Rename the file to secret.yaml \u26a0\ufe0f Ensure you don't commit this file as it has your secret token!","title":"Prerequisites"},{"location":"skaffold/#steps","text":"Start your minikube cluster, configure skaffold, and set your Docker context: minikube start --profile custom skaffold config set --global local-cluster true eval $(minikube -p custom docker-env) Start your cluster with skaffold: skaffold dev Optionally, run skaffold dev --tail=true to attach to your running containers to view log output while they run","title":"Steps"},{"location":"skaffold/#minikube-dashboard","text":"The first thing you may want to do is connect to your minikube instance via the dashboard UI. Enable the k8s dashboard by running the following command in a seperate terminal window: minikube dashboard --profile custom","title":"Minikube Dashboard"},{"location":"skaffold/#grafana","text":"Now that your cluster is up and running, you can get to your Grafana instance for metrics, logs, etc by doing the following: Open a new terminal window Obtain your Grafana password (the username will be admin ): kubectl get secret --namespace observability grafana -o jsonpath=\"{.data.admin-password}\" | base64 --decode ; echo Port forward to your grafana instance: kubectl port-forward --namespace observability service/grafana 3000:80 If your IDE does not automatically direct you, simply go to http://127.0.0.1:3000/login after port forwarding with kubectl Sign in with the credentials obtained in step two and navigate to the explore tab in Grafana Run a query like the one below to view your errbot container logs in real time!","title":"Grafana"},{"location":"slack/","text":"Slack The main errbot chatbot framework supports many different backends. Since this is a modified version of that framework, certain features work a little differently. Especially since it has been bundled as a Docker container for ease of deployments. To date I have not tested any other backends besides Discord and Slack. The good news is that both of these backends are supported with this version of errbot . There are slight differences between the two services so certain features will not work. For example, if you ask the bot to join a voice channel via the Discord backend it will work. However, Slack does not have voice channels at this time of writting so that feature will not work. Enabling the Slack Backend Backends and their configurion are setup mostly with environment variables. The steps below will walk you through what needs to be done to setup your bot to use Slack instead of Discord. Follow the official errbot docs to create a Slack bot and the corresponding token (save this token for the next step) Paste the token you get from Slack into your creds.env file CHAT_SERVICE_TOKEN='xoxb-token-here' # Slack Edit the config.env file to set your backend to Slack BACKEND='Discord' Edit the config.env file to set the bot admin(s) BOT_ADMINS='@grant.birkinbine' # Slack example (your true Slack username) Disable the following lines as you will not be using the Discord backend and Slack does not support an option for a \"bot status\" # BOT_EXTRA_BACKEND_DIR='/app/backend/err-backend-discord' # BOT_STATUS_MESSAGE='errbot | .help' Lastly, edit the src/errbot/requirements.txt file to enable Slack related pip packages. Look for the line that is a comment related to Slack and simply uncomment all the lines (packages) below it # errbot[slack] # Uncomment all the lines below this one to enable Slack support ... .. . \ud83c\udf89 Now when you start your bot with make run it will automatically connect to Slack and use that as its backend","title":"Slack"},{"location":"slack/#slack","text":"The main errbot chatbot framework supports many different backends. Since this is a modified version of that framework, certain features work a little differently. Especially since it has been bundled as a Docker container for ease of deployments. To date I have not tested any other backends besides Discord and Slack. The good news is that both of these backends are supported with this version of errbot . There are slight differences between the two services so certain features will not work. For example, if you ask the bot to join a voice channel via the Discord backend it will work. However, Slack does not have voice channels at this time of writting so that feature will not work.","title":"Slack"},{"location":"slack/#enabling-the-slack-backend","text":"Backends and their configurion are setup mostly with environment variables. The steps below will walk you through what needs to be done to setup your bot to use Slack instead of Discord. Follow the official errbot docs to create a Slack bot and the corresponding token (save this token for the next step) Paste the token you get from Slack into your creds.env file CHAT_SERVICE_TOKEN='xoxb-token-here' # Slack Edit the config.env file to set your backend to Slack BACKEND='Discord' Edit the config.env file to set the bot admin(s) BOT_ADMINS='@grant.birkinbine' # Slack example (your true Slack username) Disable the following lines as you will not be using the Discord backend and Slack does not support an option for a \"bot status\" # BOT_EXTRA_BACKEND_DIR='/app/backend/err-backend-discord' # BOT_STATUS_MESSAGE='errbot | .help' Lastly, edit the src/errbot/requirements.txt file to enable Slack related pip packages. Look for the line that is a comment related to Slack and simply uncomment all the lines (packages) below it # errbot[slack] # Uncomment all the lines below this one to enable Slack support ... .. . \ud83c\udf89 Now when you start your bot with make run it will automatically connect to Slack and use that as its backend","title":"Enabling the Slack Backend"},{"location":"policies/","text":"About Adding a privacy policy and a terms of service because Discord is making me to be a verified bot.. :\\","title":"About"},{"location":"policies/#about","text":"Adding a privacy policy and a terms of service because Discord is making me to be a verified bot.. :\\","title":"About"},{"location":"policies/privacy-policy/","text":"Privacy Policy of errbot This page is used to inform errbot users regarding our policies with the collection, use, and disclosure of Personal Information if anyone decided to use our Service, errbot If you choose to use our Service, then you agree to the collection and use of information in relation with this policy. The Personal Information that we collect are used for providing and improving the Service. We will not use or share your information with anyone except as described in this Privacy Policy. Our Privacy Policy was created with the help of the Privacy Policy Template Generator. The terms used in this Privacy Policy have the same meanings as in our Terms and Conditions, which is accessible at errbot.birki.io, unless otherwise defined in this Privacy Policy. Information Collection and Use For a better experience while using our Service, we may require you to provide us with certain personally identifiable information, including but not limited to Discord handle, chat messages sent to errbot, Discord server id. The information that we collect will be used to contact or identify you. Log Data We want to inform you that whenever you use errbot, we collect information that you send to errbot that is called Log Data. This Log Data may include information such as the commands you use and other statistics. Service Providers We may employ third-party companies and individuals due to the following reasons: To facilitate our Service; To provide the Service on our behalf; To perform Service-related services; or To assist us in analyzing how our Service is used. We want to inform our Service users that these third parties have access to your Personal Information. The reason is to perform the tasks assigned to them on our behalf. However, they are obligated not to disclose or use the information for any other purpose. Security We value your trust in providing us your Personal Information, thus we are striving to use commercially acceptable means of protecting it. But remember that no method of transmission over the internet, or method of electronic storage is 100% secure and reliable, and we cannot guarantee its absolute security. Links to Other Sites Our Service may contain links to other sites. If you click on a third-party link, you will be directed to that site. Note that these external sites are not operated by us. Therefore, we strongly advise you to review the Privacy Policy of these websites. We have no control over, and assume no responsibility for the content, privacy policies, or practices of any third-party sites or services. Changes to This Privacy Policy We may update our Privacy Policy from time to time. Thus, we advise you to review this page periodically for any changes. We will notify you of any changes by posting the new Privacy Policy on this page. These changes are effective immediately, after they are posted on this page. Contact Us If you have any questions or suggestions about our Privacy Policy, do not hesitate to contact us.","title":"Privacy policy"},{"location":"policies/terms-of-service/","text":"Errbot - Terms of Service Please read these terms of service (\"terms\", \"terms of service\") carefully before using errbot (the \"service\") operated by errbot developers (\"us\", 'we\", \"our\"). Conditions of Use We will provide their services to you, which are subject to the conditions stated below in this document. Every time you use the service, you accept the following conditions. This is why we urge you to read them carefully. Privacy Policy Before you continue using our website we advise you to read our privacy policy privacy-policy regarding our user data collection. It will help you better understand our practices. Applicable Law By using this service, you agree that the laws of the United States, without regard to principles of conflict laws, will govern these terms of service, or any dispute. Disputes Any dispute related in any way to your use of this service shall be arbitrated by state or federal court in the United States and you consent to exclusive jurisdiction and venue of such courts. Comments, Reviews, and Emails Users may use the service as long as their content is not obscene, illegal, defamatory, threatening, infringing of intellectual property rights, invasive of privacy or injurious in any other way to third parties. Content has to be free of software viruses, political campaign, and commercial solicitation. We reserve all rights (but not the obligation) to remove and/or edit such content. When you post your content, you grant errbot non-exclusive, royalty-free and irrevocable right to use, reproduce, publish, modify such content throughout the world in any media. User Account and Service Usage We reserve all rights to revoke access, edit or remove content in their sole discretion.","title":"Terms of service"}]}